# File Descriptor Layer Implementation Plan

This plan details the implementation of the file descriptor layer, enabling high-level file operations (open, read, write, close, unlink) and proper inode lifecycle management.

## 1. Define File Structures (`file.h`, `fcntl.h`)

### 1.1 Create `file.h`
Define the `struct file` to represent an open file instance.
- **Fields**:
  - `type`: Enum (`FD_NONE`, `FD_INODE`)
  - `ref`: Reference count
  - `readable`, `writable`: Permissions flags
  - `ip`: Pointer to underlying `struct inode`
  - `off`: Current R/W offset

### 1.2 Create `fcntl.h`
Define file access mode flags.
- `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREATE`

## 2. File Descriptor Management (`file.c`)

### 2.1 Basic Operations
- **`filealloc`**: Find a free slot in the global file table (`ftable`), initialize, and return it.
- **`filedup`**: Increment reference count for a file structure.
- **`fileclose`**: Decrement reference count. If zero, release the inode (`iput`) and clear the slot in file table.
- **`filestat`**: Wrapper around `stati` for `struct file`.

### 2.2 I/O Operations
- **`fileread`**:
  - Check `readable` flag.
  - Call `readi` using `f->off`.
  - Update `f->off` by bytes read.
- **`filewrite`**:
  - Check `writable` flag.
  - Loop to write data in chunks (respecting `MAXOPBLOCKS`).
  - Call `writei` using `f->off`.
  - Update `f->off`.

### 2.3 File System Operations
- **`isdirempty`**: Helper to check if a directory contains only `.` and `..`.
- **`create`**:
  - Look up parent directory.
  - If file exists, handle based on type.
  - If not, allocate new inode (`ialloc`).
  - Initialize inode (`major`, `minor`, `nlink=1`).
  - If directory, create `.` and `..` links.
  - Link new inode into parent directory (`dirlink`).
- **`unlink`**:
  - Look up parent and target inode.
  - Check conditions (not `.`/`..`, directory must be empty).
  - Write empty `dirent` to parent directory.
  - Decrement `nlink` for both parent and target.
  - Update inodes (`iupdate`).
  - Release inodes (`iput`).
- **`open`**:
  - parse `omode` flags.
  - If `O_CREATE`, call `create`.
  - Else, `namei` and check permissions.
  - Allocate `struct file` (`filealloc`).
  - Set `type`, `ip`, `off`, `readable`, `writable`.

## 3. Inode Lifecycle & Truncation (`fs.c`)

### 3.1 Implement `bfree`
Helper to free a disk block.
- Read bitmap block.
- Clear bit corresponding to block number.
- Write back to disk.

### 3.2 Implement `itrunc`
Function to free all content of an inode.
- Loop through direct blocks: call `bfree`.
- If indirect block exists:
  - Read it.
  - Loop through all pointers: call `bfree`.
  - Free the indirect block itself.
- Set `ip->size = 0` and `iupdate`.

### 3.3 Implement `iput`
Replace `irelse` with `iput` to handle deletion.
- Decrement memory reference count (`ip->ref`).
- **Deletion Logic**: If `ref == 0` AND locally `nlink == 0` (file deleted):
  - Call `itrunc` to free blocks.
  - Set `ip->type = 0`.
  - `iupdate` to mark inode free on disk.
  - `ip->valid = 0`.

## 4. Updates to Existing Code

### 4.1 Update `readi` (`fs.c`)
- Add check: return error if `ip->nlink < 1` (reading a dead inode).

### 4.2 Update `namex` (`fs.c`)
- Replace calls to `irelse` with `iput` to ensure proper cleanup.

### 4.3 Update `defs.h`
- Add forward declarations for new functions in `file.c` and updated `fs.c`.

### 4.4 Update `param.h`
- Define `NFILE` (max open files).

### 4.5 Update `Makefile`
- Add `file.o` to `OBJS`.

## 5. System Verification (`main.c`)

### 5.1 Update `welcome` function
- Test creating a file (`/foo/hello.txt`) with `open(O_CREATE)`.
- Test writing to it (`filewrite`).
- Close and re-open (`O_RDONLY`).
- Test reading back data (`fileread`).
- Test unlinking the file (`unlink`).
- Verify directory emptiness (`isdirempty`).
