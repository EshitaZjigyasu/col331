# Crash Consistency and Write-Ahead Logging Implementation Plan

This plan details the implementation of a basic file system journaling (logging) mechanism to ensure metadata consistency in the event of a crash.

## 1. The Log System (`log.c`)

### 1.1 Data Structures
Define structures to manage the log on disk and in memory.
- `struct logheader`: Tracks the count (`n`) and block numbers of pending writes.
- `struct log`: In-memory state (start block, size, device, header cache).

### 1.2 Initialization & Recovery
- **`initlog(int dev)`**:
  - Read superblock to find log location.
  - Call `recover_from_log` to replay any committed transactions from a previous crash.
- **`recover_from_log`**:
  - `read_head()`: Read the log header.
  - `install_trans()`: If `n > 0`, copy blocks from log to their final disk locations.
  - `log.lh.n = 0`: Clear the log header.
  - `write_head()`: Write cleared header to disk.

### 1.3 Core Log Operations
- **`begin_op()`**: Placeholder for transaction start.
- **`end_op()`**: Marks end of transaction; calls `commit()`.
- **`log_write(struct buf *b)`**:
  - Replaces `bwrite`.
  - Instead of writing to disk, adds block number to `log.lh.block[]`.
  - Pins the buffer in cache (`B_DIRTY`).
  - Panics if transaction is too large.

### 1.4 Commit Protocol
- **`commit()`**:
  - `write_log()`: Write all modified buffers from cache to the log area on disk.
  - `write_head()`: Write the log header to disk (**The Commit Point**).
  - `install_trans()`: Copy blocks from the log area to their real filesystem locations.
  - `log.lh.n = 0`: Clear the in-memory log header.
  - `write_head()`: Write the cleared header to disk (Transaction complete).

## 2. Integrating Logging into File System (`fs.c`)

### 2.1 Replace Writes
Replace all critical `bwrite(bp)` calls with `log_write(bp)`.
- **Block Allocation**: `balloc`, `bfree`, `bzero`.
- **Inode Updates**: `ialloc`, `iupdate`.
- **Data Writes**: `writei` (file content), `bmap` (indirect blocks).

## 3. Creating Transaction Boundaries (`file.c`)

### 3.1 Wrap System Operations
Wrap high-level modifying operations in `begin_op()` and `end_op()`.
- **`fileclose`**: Truncation/deletion of inode must be atomic.
- **`filewrite`**: Allocation and data writing must be atomic.
- **`unlink`**: Directory entry removal and inode freeing must be atomic.
- **`create`**: Inode allocation and directory linking must be atomic.
- **`open`**: Wrapped when creating files or checking directories.
- **`mkdir`**: New function wrapping `create` + `T_DIR` inside a transaction.

## 4. Updates to headers and Parameters

### 4.1 Update `param.h`
- Define `LOGSIZE` (e.g., `MAXOPBLOCKS*3`).

### 4.2 Update `defs.h`
- Add forward declarations for `log.c` functions (`initlog`, `log_write`, `begin_op`, `end_op`).
- Declare new/updated `file.c` functions (`mkdir`).

### 4.3 Update `Makefile`
- Add `log.o` to `OBJS`.

## 5. System Initialization (`main.c`)

### 5.1 Update `main`
- Call `initlog(ROOTDEV)` after `iinit`.

### 5.2 Update Tests
- Use `mkdir` in `welcome()`.
- Ensure complex operations (create, write, unlink) run correctly with the new transaction system.
